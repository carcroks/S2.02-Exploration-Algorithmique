{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Visualisation de graphe et construction de faisceaux d'ar\u00eates Le but de cette SA\u00c9 est de construire une application de visualisation de graphe. La visualisation d'information est le sous-domaine de l'informatique qui consiste \u00e0 d\u00e9finir et impl\u00e9menter des repr\u00e9sentation graphique de donn\u00e9es dans le but de permettre \u00e0 une utilisatrice ou un utilisateur de les explorer efficacement. Ici les donn\u00e9es d'int\u00e9r\u00eat seront mod\u00e9lis\u00e9es par un graphe affich\u00e9 sous la forme d'un diagramme noeud-lien. Dans ce type de diagramme, chaque noeud du graphe est repr\u00e9sent\u00e9 par une forme g\u00e9om\u00e9trique (p. ex., un cercle, un carr\u00e9, etc.) et chaque ar\u00eate par une ligne (ou courbe) reliant les formes g\u00e9om\u00e9triques correspondant \u00e0 ses extr\u00e9mit\u00e9s. Il s'agit en fait de la repr\u00e9sentation que vous avez du utiliser jusqu'\u00e0 pr\u00e9sent sans en conna\u00eetre le nom. Bien qu'intuitive, cette technique de repr\u00e9sentation souffre rapidement de \"bruit visuel\" induit par le nombre important de croisements d'ar\u00eates (mais aussi par le nombre de pixels utilis\u00e9s pour chaque ar\u00eate, le nombre de pixel de l'\u00e9cran \u00e9tant born\u00e9). Afrin d'am\u00e9liorer la lisibilit\u00e9 de telles repr\u00e9sentations, il existe deux solutions principales : (i) affecter des coordonn\u00e9es aux sommets de sorte de minimiser les croisements (et longueurs) d'ar\u00eates et (ii) s'il n'est pas possible de d\u00e9placer les sommets (car leurs positions encodent une information), d'essayer de regrouper les ar\u00eates en faisceaux afin de minimiser le nombre de pixels utilis\u00e9s pour dessiner les ar\u00eates mais aussi de mettre en \u00e9vidence les flux principaux dans le r\u00e9seau. Dans cette SA\u00c9, nous nous int\u00e9resserons \u00e0 l'approche (ii), appel\u00e9e edge bundling . Lors du projet, vous n'aurez pas \u00e0 impl\u00e9menter la partie g\u00e9rant l'affichage de graphe puisqu'elle vous est fournie. Toutefois il vous faudra impl\u00e9menter toute la partie permettant de manipuler des graphes et d'appliquer des algorithmes sur ceux-ci. \u00c9tant donn\u00e9 de la partie g\u00e9rant l'affichage vous est fourni, votre code devra s'adapter \u00e0 cet existant et s'ex\u00e9cuter correctement. Vous trouverez ici la version initiale du projet. Descriptif Au cours ce projet, vous aurez objectifs principaux qui vous permettrons \u00e0 terme d'afficher un graphe dont les ar\u00eates auront \u00e9t\u00e9 regroup\u00e9es en faisceau : (i) impl\u00e9menter une classe Graphe respectant l'interface fournie, (ii) impl\u00e9menter l'algorithme Prim permettant d'extraire un arbre couvrant de poids minimal et (iii) impl\u00e9menter l'algorithme d' edge bundling . Objectif 1 : Classe Graphe Dans un premier temps, il vous est demand\u00e9 d'impl\u00e9menter l'interface IGraph fournie \u00e0 l'exception des m\u00e9thodes getMinimumSpanningTree et bundle qui seront impl\u00e9ment\u00e9es au cours des objectifs suivants. Vous pourrez remarquer qu'il vous faudra aussi impl\u00e9menter d'autres classes afin de pouvoir manipuler un graphe, ces classes permettront de manipuler des noeuds (classe Node), des ar\u00eates (classe Edge) ainsi que des coordonn\u00e9es (classe Coord). Afin d'identifier les m\u00e9thodes n\u00e9cessaires (mais pas forc\u00e9ment suffisante), vous pouvez vous r\u00e9f\u00e9rer \u00e0 l'impl\u00e9mentation des classes GraphViewer et GraphCanvas qui les utilisent. Afin d'am\u00e9liorer la qualit\u00e9 de votre projet, il vous est demand\u00e9 d'impl\u00e9menter les tests unitaires de ces classes. C'est aussi l'occasion de mettre en oeuvre les bonnes pratiques qui vous ont \u00e9t\u00e9 pr\u00e9sent\u00e9es depuis le d\u00e9but de l'ann\u00e9e (TU, documentation, gestion de version de code, etc.). Vous pourrez remarquer la classe GraphViewer fait aussi r\u00e9f\u00e9rence \u00e0 une classe GraphLoader, vous devrez impl\u00e9menter cette classe et en particulier la m\u00e9thode loadFromFile(String filename) afin d'afficher un graphe charg\u00e9 depuis un fichier (4 fichiers d\u00e9crivant 4 graphes r\u00e9els sont fournis dans le projet). Objectif 2 : Algorithme de Prim Le deux\u00e8me objectif correspond \u00e0 l'impl\u00e9mentation de l'algorithme Prim, vu en cours, permettant d'extraire d'un graphe ar\u00eat-valu\u00e9 un arbre couvrant de poids minimal. Dans ce projet, nous consid\u00e9rerons que les poids des ar\u00eates est la distance qui s\u00e9pare ses deux sommets extr\u00e9mit\u00e9s. Ainsi l'arbre couvrant que vous allez extraire devrait \"approximer\" les distances dans d'un tel graphe. Objectifs 3 : Algorithme de construction de faisceaux d'ar\u00eates Le principe de l'algorithme d' edge bundling que nous vous demandons d'impl\u00e9menter consiste \u00e0 construire une ligne bris\u00e9e (polyligne) en calculant une s\u00e9quence de coordonn\u00e9es par lesquelles passeront chaque ar\u00eate. L'id\u00e9e est ici d'utiliser l'arbre couvrant de poids minimal comme \"guide\" pour router les ar\u00eates du graphe. Etant donn\u00e9s une ar\u00eate du graphe et l'arbre de poids minimal, l'algorithme consiste \u00e0 (1) calculer le plus court chemin dans l'arbre entre les 2 extr\u00e9mit\u00e9s de l'ar\u00eate et (2) \u00e0 utiliser la s\u00e9quence de coordonn\u00e9es des sommets de ce plus court chemin comme brisures de l'ar\u00eate. Une fois la m\u00e9thode bundle() de la classe Graphe impl\u00e9ment\u00e9e, vous devriez pouvoir afficher son r\u00e9sultat dans l'application. Attendus et \u00e9valuation Vous aurez deux livrables \u00e0 nous fournir \u00e0 la fin de votre projet : un rapport \u00e9crit ainsi que le code source de votre projet (sous la forme d'un projet Netbeans zipp\u00e9). Cette SA\u00c9 fait intervenir des comp\u00e9tences issues de plusieurs ressources : R2.01 D\u00e9veloppement Orient\u00e9 Objet, R2.07 Graphes et R2.09 M\u00e9thodes Num\u00e9riques. Vos enseignants de ces ressources \u00e9valueront donc des aspects diff\u00e9rents de votre projet. R2.01 D\u00e9veloppement orient\u00e9 objet En ce qui concerne la ressource R2.01, seront \u00e9valu\u00e9s le rapport d\u00e9crivant vos choix de conception et d'impl\u00e9mentation ainsi que la qualit\u00e9 g\u00e9n\u00e9rale de votre code (bonnes pratiques, TU, etc.). Les enseignants de cette ressources seront particuli\u00e8rement attentif \u00e0 la qualit\u00e9 de la conception que vous proposerez. @Bruno : il faudrait que tu me disent quels sont tes attendus R2.07 Graphes En ce qui concerne la ressource R2.07, seront \u00e9valu\u00e9s les algorithmes Prim et de regroupement en faisceau d'ar\u00eates. Attention \u00e0 bien impl\u00e9menter les algorithmes attendus mais aussi \u00e0 la compl\u00e9xit\u00e9 de vos impl\u00e9mentations. R2.09 M\u00e9thodes num\u00e9rique En ce qui concerne la ressource R2.09, seront \u00e9valu\u00e9s les compl\u00e9xit\u00e9s des m\u00e9thodes de la classe Graphe. Il vous est demand\u00e9 ici de calculer les compl\u00e9xit\u00e9s de chacunes des m\u00e9thodes de cette classet et de les pr\u00e9senter dans une partie sp\u00e9cifique de votre rapport.","title":"Pr\u00e9sentation"},{"location":"index.html#visualisation-de-graphe-et-construction-de-faisceaux-daretes","text":"Le but de cette SA\u00c9 est de construire une application de visualisation de graphe. La visualisation d'information est le sous-domaine de l'informatique qui consiste \u00e0 d\u00e9finir et impl\u00e9menter des repr\u00e9sentation graphique de donn\u00e9es dans le but de permettre \u00e0 une utilisatrice ou un utilisateur de les explorer efficacement. Ici les donn\u00e9es d'int\u00e9r\u00eat seront mod\u00e9lis\u00e9es par un graphe affich\u00e9 sous la forme d'un diagramme noeud-lien. Dans ce type de diagramme, chaque noeud du graphe est repr\u00e9sent\u00e9 par une forme g\u00e9om\u00e9trique (p. ex., un cercle, un carr\u00e9, etc.) et chaque ar\u00eate par une ligne (ou courbe) reliant les formes g\u00e9om\u00e9triques correspondant \u00e0 ses extr\u00e9mit\u00e9s. Il s'agit en fait de la repr\u00e9sentation que vous avez du utiliser jusqu'\u00e0 pr\u00e9sent sans en conna\u00eetre le nom. Bien qu'intuitive, cette technique de repr\u00e9sentation souffre rapidement de \"bruit visuel\" induit par le nombre important de croisements d'ar\u00eates (mais aussi par le nombre de pixels utilis\u00e9s pour chaque ar\u00eate, le nombre de pixel de l'\u00e9cran \u00e9tant born\u00e9). Afrin d'am\u00e9liorer la lisibilit\u00e9 de telles repr\u00e9sentations, il existe deux solutions principales : (i) affecter des coordonn\u00e9es aux sommets de sorte de minimiser les croisements (et longueurs) d'ar\u00eates et (ii) s'il n'est pas possible de d\u00e9placer les sommets (car leurs positions encodent une information), d'essayer de regrouper les ar\u00eates en faisceaux afin de minimiser le nombre de pixels utilis\u00e9s pour dessiner les ar\u00eates mais aussi de mettre en \u00e9vidence les flux principaux dans le r\u00e9seau. Dans cette SA\u00c9, nous nous int\u00e9resserons \u00e0 l'approche (ii), appel\u00e9e edge bundling . Lors du projet, vous n'aurez pas \u00e0 impl\u00e9menter la partie g\u00e9rant l'affichage de graphe puisqu'elle vous est fournie. Toutefois il vous faudra impl\u00e9menter toute la partie permettant de manipuler des graphes et d'appliquer des algorithmes sur ceux-ci. \u00c9tant donn\u00e9 de la partie g\u00e9rant l'affichage vous est fourni, votre code devra s'adapter \u00e0 cet existant et s'ex\u00e9cuter correctement. Vous trouverez ici la version initiale du projet.","title":"Visualisation de graphe et construction de faisceaux d'ar\u00eates"},{"location":"index.html#descriptif","text":"Au cours ce projet, vous aurez objectifs principaux qui vous permettrons \u00e0 terme d'afficher un graphe dont les ar\u00eates auront \u00e9t\u00e9 regroup\u00e9es en faisceau : (i) impl\u00e9menter une classe Graphe respectant l'interface fournie, (ii) impl\u00e9menter l'algorithme Prim permettant d'extraire un arbre couvrant de poids minimal et (iii) impl\u00e9menter l'algorithme d' edge bundling .","title":"Descriptif"},{"location":"index.html#objectif-1-classe-graphe","text":"Dans un premier temps, il vous est demand\u00e9 d'impl\u00e9menter l'interface IGraph fournie \u00e0 l'exception des m\u00e9thodes getMinimumSpanningTree et bundle qui seront impl\u00e9ment\u00e9es au cours des objectifs suivants. Vous pourrez remarquer qu'il vous faudra aussi impl\u00e9menter d'autres classes afin de pouvoir manipuler un graphe, ces classes permettront de manipuler des noeuds (classe Node), des ar\u00eates (classe Edge) ainsi que des coordonn\u00e9es (classe Coord). Afin d'identifier les m\u00e9thodes n\u00e9cessaires (mais pas forc\u00e9ment suffisante), vous pouvez vous r\u00e9f\u00e9rer \u00e0 l'impl\u00e9mentation des classes GraphViewer et GraphCanvas qui les utilisent. Afin d'am\u00e9liorer la qualit\u00e9 de votre projet, il vous est demand\u00e9 d'impl\u00e9menter les tests unitaires de ces classes. C'est aussi l'occasion de mettre en oeuvre les bonnes pratiques qui vous ont \u00e9t\u00e9 pr\u00e9sent\u00e9es depuis le d\u00e9but de l'ann\u00e9e (TU, documentation, gestion de version de code, etc.). Vous pourrez remarquer la classe GraphViewer fait aussi r\u00e9f\u00e9rence \u00e0 une classe GraphLoader, vous devrez impl\u00e9menter cette classe et en particulier la m\u00e9thode loadFromFile(String filename) afin d'afficher un graphe charg\u00e9 depuis un fichier (4 fichiers d\u00e9crivant 4 graphes r\u00e9els sont fournis dans le projet).","title":"Objectif 1 : Classe Graphe"},{"location":"index.html#objectif-2-algorithme-de-prim","text":"Le deux\u00e8me objectif correspond \u00e0 l'impl\u00e9mentation de l'algorithme Prim, vu en cours, permettant d'extraire d'un graphe ar\u00eat-valu\u00e9 un arbre couvrant de poids minimal. Dans ce projet, nous consid\u00e9rerons que les poids des ar\u00eates est la distance qui s\u00e9pare ses deux sommets extr\u00e9mit\u00e9s. Ainsi l'arbre couvrant que vous allez extraire devrait \"approximer\" les distances dans d'un tel graphe.","title":"Objectif 2 : Algorithme de Prim"},{"location":"index.html#objectifs-3-algorithme-de-construction-de-faisceaux-daretes","text":"Le principe de l'algorithme d' edge bundling que nous vous demandons d'impl\u00e9menter consiste \u00e0 construire une ligne bris\u00e9e (polyligne) en calculant une s\u00e9quence de coordonn\u00e9es par lesquelles passeront chaque ar\u00eate. L'id\u00e9e est ici d'utiliser l'arbre couvrant de poids minimal comme \"guide\" pour router les ar\u00eates du graphe. Etant donn\u00e9s une ar\u00eate du graphe et l'arbre de poids minimal, l'algorithme consiste \u00e0 (1) calculer le plus court chemin dans l'arbre entre les 2 extr\u00e9mit\u00e9s de l'ar\u00eate et (2) \u00e0 utiliser la s\u00e9quence de coordonn\u00e9es des sommets de ce plus court chemin comme brisures de l'ar\u00eate. Une fois la m\u00e9thode bundle() de la classe Graphe impl\u00e9ment\u00e9e, vous devriez pouvoir afficher son r\u00e9sultat dans l'application.","title":"Objectifs 3 : Algorithme de construction de faisceaux d'ar\u00eates"},{"location":"index.html#attendus-et-evaluation","text":"Vous aurez deux livrables \u00e0 nous fournir \u00e0 la fin de votre projet : un rapport \u00e9crit ainsi que le code source de votre projet (sous la forme d'un projet Netbeans zipp\u00e9). Cette SA\u00c9 fait intervenir des comp\u00e9tences issues de plusieurs ressources : R2.01 D\u00e9veloppement Orient\u00e9 Objet, R2.07 Graphes et R2.09 M\u00e9thodes Num\u00e9riques. Vos enseignants de ces ressources \u00e9valueront donc des aspects diff\u00e9rents de votre projet.","title":"Attendus et \u00e9valuation"},{"location":"index.html#r201-developpement-oriente-objet","text":"En ce qui concerne la ressource R2.01, seront \u00e9valu\u00e9s le rapport d\u00e9crivant vos choix de conception et d'impl\u00e9mentation ainsi que la qualit\u00e9 g\u00e9n\u00e9rale de votre code (bonnes pratiques, TU, etc.). Les enseignants de cette ressources seront particuli\u00e8rement attentif \u00e0 la qualit\u00e9 de la conception que vous proposerez. @Bruno : il faudrait que tu me disent quels sont tes attendus","title":"R2.01 D\u00e9veloppement orient\u00e9 objet"},{"location":"index.html#r207-graphes","text":"En ce qui concerne la ressource R2.07, seront \u00e9valu\u00e9s les algorithmes Prim et de regroupement en faisceau d'ar\u00eates. Attention \u00e0 bien impl\u00e9menter les algorithmes attendus mais aussi \u00e0 la compl\u00e9xit\u00e9 de vos impl\u00e9mentations.","title":"R2.07 Graphes"},{"location":"index.html#r209-methodes-numerique","text":"En ce qui concerne la ressource R2.09, seront \u00e9valu\u00e9s les compl\u00e9xit\u00e9s des m\u00e9thodes de la classe Graphe. Il vous est demand\u00e9 ici de calculer les compl\u00e9xit\u00e9s de chacunes des m\u00e9thodes de cette classet et de les pr\u00e9senter dans une partie sp\u00e9cifique de votre rapport.","title":"R2.09 M\u00e9thodes num\u00e9rique"}]}